// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	openfgav1 "github.com/openfga/api/proto/openfga/v1"
)

// OpenFGAServiceClient is an autogenerated mock type for the OpenFGAServiceClient type
type OpenFGAServiceClient struct {
	mock.Mock
}

type OpenFGAServiceClient_Expecter struct {
	mock *mock.Mock
}

func (_m *OpenFGAServiceClient) EXPECT() *OpenFGAServiceClient_Expecter {
	return &OpenFGAServiceClient_Expecter{mock: &_m.Mock}
}

// Check provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) Check(ctx context.Context, in *openfgav1.CheckRequest, opts ...grpc.CallOption) (*openfgav1.CheckResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Check")
	}

	var r0 *openfgav1.CheckResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) (*openfgav1.CheckResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) *openfgav1.CheckResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.CheckResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_Check_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Check'
type OpenFGAServiceClient_Check_Call struct {
	*mock.Call
}

// Check is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.CheckRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) Check(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_Check_Call {
	return &OpenFGAServiceClient_Check_Call{Call: _e.mock.On("Check",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_Check_Call) Run(run func(ctx context.Context, in *openfgav1.CheckRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_Check_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.CheckRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_Check_Call) Return(_a0 *openfgav1.CheckResponse, _a1 error) *OpenFGAServiceClient_Check_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_Check_Call) RunAndReturn(run func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) (*openfgav1.CheckResponse, error)) *OpenFGAServiceClient_Check_Call {
	_c.Call.Return(run)
	return _c
}

// CreateStore provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) CreateStore(ctx context.Context, in *openfgav1.CreateStoreRequest, opts ...grpc.CallOption) (*openfgav1.CreateStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStore")
	}

	var r0 *openfgav1.CreateStoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) (*openfgav1.CreateStoreResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) *openfgav1.CreateStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.CreateStoreResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_CreateStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStore'
type OpenFGAServiceClient_CreateStore_Call struct {
	*mock.Call
}

// CreateStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.CreateStoreRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) CreateStore(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_CreateStore_Call {
	return &OpenFGAServiceClient_CreateStore_Call{Call: _e.mock.On("CreateStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_CreateStore_Call) Run(run func(ctx context.Context, in *openfgav1.CreateStoreRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_CreateStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.CreateStoreRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_CreateStore_Call) Return(_a0 *openfgav1.CreateStoreResponse, _a1 error) *OpenFGAServiceClient_CreateStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_CreateStore_Call) RunAndReturn(run func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) (*openfgav1.CreateStoreResponse, error)) *OpenFGAServiceClient_CreateStore_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteStore provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) DeleteStore(ctx context.Context, in *openfgav1.DeleteStoreRequest, opts ...grpc.CallOption) (*openfgav1.DeleteStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStore")
	}

	var r0 *openfgav1.DeleteStoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) (*openfgav1.DeleteStoreResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) *openfgav1.DeleteStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.DeleteStoreResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_DeleteStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteStore'
type OpenFGAServiceClient_DeleteStore_Call struct {
	*mock.Call
}

// DeleteStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.DeleteStoreRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) DeleteStore(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_DeleteStore_Call {
	return &OpenFGAServiceClient_DeleteStore_Call{Call: _e.mock.On("DeleteStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_DeleteStore_Call) Run(run func(ctx context.Context, in *openfgav1.DeleteStoreRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_DeleteStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.DeleteStoreRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_DeleteStore_Call) Return(_a0 *openfgav1.DeleteStoreResponse, _a1 error) *OpenFGAServiceClient_DeleteStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_DeleteStore_Call) RunAndReturn(run func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) (*openfgav1.DeleteStoreResponse, error)) *OpenFGAServiceClient_DeleteStore_Call {
	_c.Call.Return(run)
	return _c
}

// Expand provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) Expand(ctx context.Context, in *openfgav1.ExpandRequest, opts ...grpc.CallOption) (*openfgav1.ExpandResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Expand")
	}

	var r0 *openfgav1.ExpandResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) (*openfgav1.ExpandResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) *openfgav1.ExpandResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ExpandResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_Expand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Expand'
type OpenFGAServiceClient_Expand_Call struct {
	*mock.Call
}

// Expand is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ExpandRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) Expand(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_Expand_Call {
	return &OpenFGAServiceClient_Expand_Call{Call: _e.mock.On("Expand",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_Expand_Call) Run(run func(ctx context.Context, in *openfgav1.ExpandRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_Expand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ExpandRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_Expand_Call) Return(_a0 *openfgav1.ExpandResponse, _a1 error) *OpenFGAServiceClient_Expand_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_Expand_Call) RunAndReturn(run func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) (*openfgav1.ExpandResponse, error)) *OpenFGAServiceClient_Expand_Call {
	_c.Call.Return(run)
	return _c
}

// GetStore provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) GetStore(ctx context.Context, in *openfgav1.GetStoreRequest, opts ...grpc.CallOption) (*openfgav1.GetStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStore")
	}

	var r0 *openfgav1.GetStoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) (*openfgav1.GetStoreResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) *openfgav1.GetStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.GetStoreResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_GetStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStore'
type OpenFGAServiceClient_GetStore_Call struct {
	*mock.Call
}

// GetStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.GetStoreRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) GetStore(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_GetStore_Call {
	return &OpenFGAServiceClient_GetStore_Call{Call: _e.mock.On("GetStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_GetStore_Call) Run(run func(ctx context.Context, in *openfgav1.GetStoreRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_GetStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.GetStoreRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_GetStore_Call) Return(_a0 *openfgav1.GetStoreResponse, _a1 error) *OpenFGAServiceClient_GetStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_GetStore_Call) RunAndReturn(run func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) (*openfgav1.GetStoreResponse, error)) *OpenFGAServiceClient_GetStore_Call {
	_c.Call.Return(run)
	return _c
}

// ListObjects provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ListObjects(ctx context.Context, in *openfgav1.ListObjectsRequest, opts ...grpc.CallOption) (*openfgav1.ListObjectsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListObjects")
	}

	var r0 *openfgav1.ListObjectsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) (*openfgav1.ListObjectsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) *openfgav1.ListObjectsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListObjectsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_ListObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListObjects'
type OpenFGAServiceClient_ListObjects_Call struct {
	*mock.Call
}

// ListObjects is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ListObjectsRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) ListObjects(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_ListObjects_Call {
	return &OpenFGAServiceClient_ListObjects_Call{Call: _e.mock.On("ListObjects",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_ListObjects_Call) Run(run func(ctx context.Context, in *openfgav1.ListObjectsRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_ListObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ListObjectsRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_ListObjects_Call) Return(_a0 *openfgav1.ListObjectsResponse, _a1 error) *OpenFGAServiceClient_ListObjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_ListObjects_Call) RunAndReturn(run func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) (*openfgav1.ListObjectsResponse, error)) *OpenFGAServiceClient_ListObjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListStores provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ListStores(ctx context.Context, in *openfgav1.ListStoresRequest, opts ...grpc.CallOption) (*openfgav1.ListStoresResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStores")
	}

	var r0 *openfgav1.ListStoresResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) (*openfgav1.ListStoresResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) *openfgav1.ListStoresResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListStoresResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_ListStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListStores'
type OpenFGAServiceClient_ListStores_Call struct {
	*mock.Call
}

// ListStores is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ListStoresRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) ListStores(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_ListStores_Call {
	return &OpenFGAServiceClient_ListStores_Call{Call: _e.mock.On("ListStores",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_ListStores_Call) Run(run func(ctx context.Context, in *openfgav1.ListStoresRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_ListStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ListStoresRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_ListStores_Call) Return(_a0 *openfgav1.ListStoresResponse, _a1 error) *OpenFGAServiceClient_ListStores_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_ListStores_Call) RunAndReturn(run func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) (*openfgav1.ListStoresResponse, error)) *OpenFGAServiceClient_ListStores_Call {
	_c.Call.Return(run)
	return _c
}

// ListUsers provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ListUsers(ctx context.Context, in *openfgav1.ListUsersRequest, opts ...grpc.CallOption) (*openfgav1.ListUsersResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 *openfgav1.ListUsersResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) (*openfgav1.ListUsersResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) *openfgav1.ListUsersResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListUsersResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_ListUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUsers'
type OpenFGAServiceClient_ListUsers_Call struct {
	*mock.Call
}

// ListUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ListUsersRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) ListUsers(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_ListUsers_Call {
	return &OpenFGAServiceClient_ListUsers_Call{Call: _e.mock.On("ListUsers",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_ListUsers_Call) Run(run func(ctx context.Context, in *openfgav1.ListUsersRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_ListUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ListUsersRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_ListUsers_Call) Return(_a0 *openfgav1.ListUsersResponse, _a1 error) *OpenFGAServiceClient_ListUsers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_ListUsers_Call) RunAndReturn(run func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) (*openfgav1.ListUsersResponse, error)) *OpenFGAServiceClient_ListUsers_Call {
	_c.Call.Return(run)
	return _c
}

// Read provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) Read(ctx context.Context, in *openfgav1.ReadRequest, opts ...grpc.CallOption) (*openfgav1.ReadResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 *openfgav1.ReadResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) (*openfgav1.ReadResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) *openfgav1.ReadResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type OpenFGAServiceClient_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) Read(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_Read_Call {
	return &OpenFGAServiceClient_Read_Call{Call: _e.mock.On("Read",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_Read_Call) Run(run func(ctx context.Context, in *openfgav1.ReadRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ReadRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_Read_Call) Return(_a0 *openfgav1.ReadResponse, _a1 error) *OpenFGAServiceClient_Read_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_Read_Call) RunAndReturn(run func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) (*openfgav1.ReadResponse, error)) *OpenFGAServiceClient_Read_Call {
	_c.Call.Return(run)
	return _c
}

// ReadAssertions provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ReadAssertions(ctx context.Context, in *openfgav1.ReadAssertionsRequest, opts ...grpc.CallOption) (*openfgav1.ReadAssertionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReadAssertions")
	}

	var r0 *openfgav1.ReadAssertionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) (*openfgav1.ReadAssertionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) *openfgav1.ReadAssertionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAssertionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_ReadAssertions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadAssertions'
type OpenFGAServiceClient_ReadAssertions_Call struct {
	*mock.Call
}

// ReadAssertions is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadAssertionsRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) ReadAssertions(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_ReadAssertions_Call {
	return &OpenFGAServiceClient_ReadAssertions_Call{Call: _e.mock.On("ReadAssertions",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_ReadAssertions_Call) Run(run func(ctx context.Context, in *openfgav1.ReadAssertionsRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_ReadAssertions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ReadAssertionsRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_ReadAssertions_Call) Return(_a0 *openfgav1.ReadAssertionsResponse, _a1 error) *OpenFGAServiceClient_ReadAssertions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_ReadAssertions_Call) RunAndReturn(run func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) (*openfgav1.ReadAssertionsResponse, error)) *OpenFGAServiceClient_ReadAssertions_Call {
	_c.Call.Return(run)
	return _c
}

// ReadAuthorizationModel provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ReadAuthorizationModel(ctx context.Context, in *openfgav1.ReadAuthorizationModelRequest, opts ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReadAuthorizationModel")
	}

	var r0 *openfgav1.ReadAuthorizationModelResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) *openfgav1.ReadAuthorizationModelResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAuthorizationModelResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_ReadAuthorizationModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadAuthorizationModel'
type OpenFGAServiceClient_ReadAuthorizationModel_Call struct {
	*mock.Call
}

// ReadAuthorizationModel is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadAuthorizationModelRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) ReadAuthorizationModel(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_ReadAuthorizationModel_Call {
	return &OpenFGAServiceClient_ReadAuthorizationModel_Call{Call: _e.mock.On("ReadAuthorizationModel",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_ReadAuthorizationModel_Call) Run(run func(ctx context.Context, in *openfgav1.ReadAuthorizationModelRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_ReadAuthorizationModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ReadAuthorizationModelRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_ReadAuthorizationModel_Call) Return(_a0 *openfgav1.ReadAuthorizationModelResponse, _a1 error) *OpenFGAServiceClient_ReadAuthorizationModel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_ReadAuthorizationModel_Call) RunAndReturn(run func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelResponse, error)) *OpenFGAServiceClient_ReadAuthorizationModel_Call {
	_c.Call.Return(run)
	return _c
}

// ReadAuthorizationModels provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ReadAuthorizationModels(ctx context.Context, in *openfgav1.ReadAuthorizationModelsRequest, opts ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReadAuthorizationModels")
	}

	var r0 *openfgav1.ReadAuthorizationModelsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) *openfgav1.ReadAuthorizationModelsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAuthorizationModelsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_ReadAuthorizationModels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadAuthorizationModels'
type OpenFGAServiceClient_ReadAuthorizationModels_Call struct {
	*mock.Call
}

// ReadAuthorizationModels is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadAuthorizationModelsRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) ReadAuthorizationModels(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_ReadAuthorizationModels_Call {
	return &OpenFGAServiceClient_ReadAuthorizationModels_Call{Call: _e.mock.On("ReadAuthorizationModels",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_ReadAuthorizationModels_Call) Run(run func(ctx context.Context, in *openfgav1.ReadAuthorizationModelsRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_ReadAuthorizationModels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ReadAuthorizationModelsRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_ReadAuthorizationModels_Call) Return(_a0 *openfgav1.ReadAuthorizationModelsResponse, _a1 error) *OpenFGAServiceClient_ReadAuthorizationModels_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_ReadAuthorizationModels_Call) RunAndReturn(run func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelsResponse, error)) *OpenFGAServiceClient_ReadAuthorizationModels_Call {
	_c.Call.Return(run)
	return _c
}

// ReadChanges provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ReadChanges(ctx context.Context, in *openfgav1.ReadChangesRequest, opts ...grpc.CallOption) (*openfgav1.ReadChangesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReadChanges")
	}

	var r0 *openfgav1.ReadChangesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) (*openfgav1.ReadChangesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) *openfgav1.ReadChangesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadChangesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_ReadChanges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadChanges'
type OpenFGAServiceClient_ReadChanges_Call struct {
	*mock.Call
}

// ReadChanges is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadChangesRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) ReadChanges(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_ReadChanges_Call {
	return &OpenFGAServiceClient_ReadChanges_Call{Call: _e.mock.On("ReadChanges",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_ReadChanges_Call) Run(run func(ctx context.Context, in *openfgav1.ReadChangesRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_ReadChanges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ReadChangesRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_ReadChanges_Call) Return(_a0 *openfgav1.ReadChangesResponse, _a1 error) *OpenFGAServiceClient_ReadChanges_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_ReadChanges_Call) RunAndReturn(run func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) (*openfgav1.ReadChangesResponse, error)) *OpenFGAServiceClient_ReadChanges_Call {
	_c.Call.Return(run)
	return _c
}

// StreamedListObjects provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) StreamedListObjects(ctx context.Context, in *openfgav1.StreamedListObjectsRequest, opts ...grpc.CallOption) (openfgav1.OpenFGAService_StreamedListObjectsClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StreamedListObjects")
	}

	var r0 openfgav1.OpenFGAService_StreamedListObjectsClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) (openfgav1.OpenFGAService_StreamedListObjectsClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) openfgav1.OpenFGAService_StreamedListObjectsClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(openfgav1.OpenFGAService_StreamedListObjectsClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_StreamedListObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamedListObjects'
type OpenFGAServiceClient_StreamedListObjects_Call struct {
	*mock.Call
}

// StreamedListObjects is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.StreamedListObjectsRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) StreamedListObjects(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_StreamedListObjects_Call {
	return &OpenFGAServiceClient_StreamedListObjects_Call{Call: _e.mock.On("StreamedListObjects",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_StreamedListObjects_Call) Run(run func(ctx context.Context, in *openfgav1.StreamedListObjectsRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_StreamedListObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.StreamedListObjectsRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_StreamedListObjects_Call) Return(_a0 openfgav1.OpenFGAService_StreamedListObjectsClient, _a1 error) *OpenFGAServiceClient_StreamedListObjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_StreamedListObjects_Call) RunAndReturn(run func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) (openfgav1.OpenFGAService_StreamedListObjectsClient, error)) *OpenFGAServiceClient_StreamedListObjects_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStore provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) UpdateStore(ctx context.Context, in *openfgav1.UpdateStoreRequest, opts ...grpc.CallOption) (*openfgav1.UpdateStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStore")
	}

	var r0 *openfgav1.UpdateStoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) (*openfgav1.UpdateStoreResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) *openfgav1.UpdateStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.UpdateStoreResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_UpdateStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStore'
type OpenFGAServiceClient_UpdateStore_Call struct {
	*mock.Call
}

// UpdateStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.UpdateStoreRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) UpdateStore(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_UpdateStore_Call {
	return &OpenFGAServiceClient_UpdateStore_Call{Call: _e.mock.On("UpdateStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_UpdateStore_Call) Run(run func(ctx context.Context, in *openfgav1.UpdateStoreRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_UpdateStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.UpdateStoreRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_UpdateStore_Call) Return(_a0 *openfgav1.UpdateStoreResponse, _a1 error) *OpenFGAServiceClient_UpdateStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_UpdateStore_Call) RunAndReturn(run func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) (*openfgav1.UpdateStoreResponse, error)) *OpenFGAServiceClient_UpdateStore_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) Write(ctx context.Context, in *openfgav1.WriteRequest, opts ...grpc.CallOption) (*openfgav1.WriteResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 *openfgav1.WriteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) (*openfgav1.WriteResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) *openfgav1.WriteResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type OpenFGAServiceClient_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.WriteRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) Write(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_Write_Call {
	return &OpenFGAServiceClient_Write_Call{Call: _e.mock.On("Write",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_Write_Call) Run(run func(ctx context.Context, in *openfgav1.WriteRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.WriteRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_Write_Call) Return(_a0 *openfgav1.WriteResponse, _a1 error) *OpenFGAServiceClient_Write_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_Write_Call) RunAndReturn(run func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) (*openfgav1.WriteResponse, error)) *OpenFGAServiceClient_Write_Call {
	_c.Call.Return(run)
	return _c
}

// WriteAssertions provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) WriteAssertions(ctx context.Context, in *openfgav1.WriteAssertionsRequest, opts ...grpc.CallOption) (*openfgav1.WriteAssertionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WriteAssertions")
	}

	var r0 *openfgav1.WriteAssertionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) (*openfgav1.WriteAssertionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) *openfgav1.WriteAssertionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteAssertionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_WriteAssertions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteAssertions'
type OpenFGAServiceClient_WriteAssertions_Call struct {
	*mock.Call
}

// WriteAssertions is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.WriteAssertionsRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) WriteAssertions(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_WriteAssertions_Call {
	return &OpenFGAServiceClient_WriteAssertions_Call{Call: _e.mock.On("WriteAssertions",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_WriteAssertions_Call) Run(run func(ctx context.Context, in *openfgav1.WriteAssertionsRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_WriteAssertions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.WriteAssertionsRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_WriteAssertions_Call) Return(_a0 *openfgav1.WriteAssertionsResponse, _a1 error) *OpenFGAServiceClient_WriteAssertions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_WriteAssertions_Call) RunAndReturn(run func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) (*openfgav1.WriteAssertionsResponse, error)) *OpenFGAServiceClient_WriteAssertions_Call {
	_c.Call.Return(run)
	return _c
}

// WriteAuthorizationModel provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) WriteAuthorizationModel(ctx context.Context, in *openfgav1.WriteAuthorizationModelRequest, opts ...grpc.CallOption) (*openfgav1.WriteAuthorizationModelResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WriteAuthorizationModel")
	}

	var r0 *openfgav1.WriteAuthorizationModelResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) (*openfgav1.WriteAuthorizationModelResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) *openfgav1.WriteAuthorizationModelResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteAuthorizationModelResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFGAServiceClient_WriteAuthorizationModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteAuthorizationModel'
type OpenFGAServiceClient_WriteAuthorizationModel_Call struct {
	*mock.Call
}

// WriteAuthorizationModel is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.WriteAuthorizationModelRequest
//   - opts ...grpc.CallOption
func (_e *OpenFGAServiceClient_Expecter) WriteAuthorizationModel(ctx interface{}, in interface{}, opts ...interface{}) *OpenFGAServiceClient_WriteAuthorizationModel_Call {
	return &OpenFGAServiceClient_WriteAuthorizationModel_Call{Call: _e.mock.On("WriteAuthorizationModel",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *OpenFGAServiceClient_WriteAuthorizationModel_Call) Run(run func(ctx context.Context, in *openfgav1.WriteAuthorizationModelRequest, opts ...grpc.CallOption)) *OpenFGAServiceClient_WriteAuthorizationModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.WriteAuthorizationModelRequest), variadicArgs...)
	})
	return _c
}

func (_c *OpenFGAServiceClient_WriteAuthorizationModel_Call) Return(_a0 *openfgav1.WriteAuthorizationModelResponse, _a1 error) *OpenFGAServiceClient_WriteAuthorizationModel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *OpenFGAServiceClient_WriteAuthorizationModel_Call) RunAndReturn(run func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) (*openfgav1.WriteAuthorizationModelResponse, error)) *OpenFGAServiceClient_WriteAuthorizationModel_Call {
	_c.Call.Return(run)
	return _c
}

// NewOpenFGAServiceClient creates a new instance of OpenFGAServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewOpenFGAServiceClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *OpenFGAServiceClient {
	mock := &OpenFGAServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
