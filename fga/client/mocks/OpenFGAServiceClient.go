// Code generated by mockery v3.0.0-alpha.0. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	openfgav1 "github.com/openfga/api/proto/openfga/v1"
)

// OpenFGAServiceClient is an autogenerated mock type for the OpenFGAServiceClient type
type OpenFGAServiceClient struct {
	mock.Mock
}

// Check provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) Check(ctx context.Context, in *openfgav1.CheckRequest, opts ...grpc.CallOption) (*openfgav1.CheckResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.CheckResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) *openfgav1.CheckResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.CheckResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStore provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) CreateStore(ctx context.Context, in *openfgav1.CreateStoreRequest, opts ...grpc.CallOption) (*openfgav1.CreateStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.CreateStoreResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) *openfgav1.CreateStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.CreateStoreResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteStore provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) DeleteStore(ctx context.Context, in *openfgav1.DeleteStoreRequest, opts ...grpc.CallOption) (*openfgav1.DeleteStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.DeleteStoreResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) *openfgav1.DeleteStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.DeleteStoreResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Expand provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) Expand(ctx context.Context, in *openfgav1.ExpandRequest, opts ...grpc.CallOption) (*openfgav1.ExpandResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.ExpandResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) *openfgav1.ExpandResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ExpandResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStore provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) GetStore(ctx context.Context, in *openfgav1.GetStoreRequest, opts ...grpc.CallOption) (*openfgav1.GetStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.GetStoreResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) *openfgav1.GetStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.GetStoreResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListObjects provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ListObjects(ctx context.Context, in *openfgav1.ListObjectsRequest, opts ...grpc.CallOption) (*openfgav1.ListObjectsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.ListObjectsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) *openfgav1.ListObjectsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListObjectsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStores provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ListStores(ctx context.Context, in *openfgav1.ListStoresRequest, opts ...grpc.CallOption) (*openfgav1.ListStoresResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.ListStoresResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) *openfgav1.ListStoresResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListStoresResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUsers provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ListUsers(ctx context.Context, in *openfgav1.ListUsersRequest, opts ...grpc.CallOption) (*openfgav1.ListUsersResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.ListUsersResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) *openfgav1.ListUsersResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListUsersResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Read provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) Read(ctx context.Context, in *openfgav1.ReadRequest, opts ...grpc.CallOption) (*openfgav1.ReadResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.ReadResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) *openfgav1.ReadResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadAssertions provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ReadAssertions(ctx context.Context, in *openfgav1.ReadAssertionsRequest, opts ...grpc.CallOption) (*openfgav1.ReadAssertionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.ReadAssertionsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) *openfgav1.ReadAssertionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAssertionsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadAuthorizationModel provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ReadAuthorizationModel(ctx context.Context, in *openfgav1.ReadAuthorizationModelRequest, opts ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.ReadAuthorizationModelResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) *openfgav1.ReadAuthorizationModelResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAuthorizationModelResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadAuthorizationModels provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ReadAuthorizationModels(ctx context.Context, in *openfgav1.ReadAuthorizationModelsRequest, opts ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.ReadAuthorizationModelsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) *openfgav1.ReadAuthorizationModelsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAuthorizationModelsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadChanges provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) ReadChanges(ctx context.Context, in *openfgav1.ReadChangesRequest, opts ...grpc.CallOption) (*openfgav1.ReadChangesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.ReadChangesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) *openfgav1.ReadChangesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadChangesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StreamedListObjects provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) StreamedListObjects(ctx context.Context, in *openfgav1.StreamedListObjectsRequest, opts ...grpc.CallOption) (openfgav1.OpenFGAService_StreamedListObjectsClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 openfgav1.OpenFGAService_StreamedListObjectsClient
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) openfgav1.OpenFGAService_StreamedListObjectsClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(openfgav1.OpenFGAService_StreamedListObjectsClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStore provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) UpdateStore(ctx context.Context, in *openfgav1.UpdateStoreRequest, opts ...grpc.CallOption) (*openfgav1.UpdateStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.UpdateStoreResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) *openfgav1.UpdateStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.UpdateStoreResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Write provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) Write(ctx context.Context, in *openfgav1.WriteRequest, opts ...grpc.CallOption) (*openfgav1.WriteResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.WriteResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) *openfgav1.WriteResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WriteAssertions provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) WriteAssertions(ctx context.Context, in *openfgav1.WriteAssertionsRequest, opts ...grpc.CallOption) (*openfgav1.WriteAssertionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.WriteAssertionsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) *openfgav1.WriteAssertionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteAssertionsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WriteAuthorizationModel provides a mock function with given fields: ctx, in, opts
func (_m *OpenFGAServiceClient) WriteAuthorizationModel(ctx context.Context, in *openfgav1.WriteAuthorizationModelRequest, opts ...grpc.CallOption) (*openfgav1.WriteAuthorizationModelResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *openfgav1.WriteAuthorizationModelResponse
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) *openfgav1.WriteAuthorizationModelResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteAuthorizationModelResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewOpenFGAServiceClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewOpenFGAServiceClient creates a new instance of OpenFGAServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewOpenFGAServiceClient(t mockConstructorTestingTNewOpenFGAServiceClient) *OpenFGAServiceClient {
	mock := &OpenFGAServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
